package com.ece596.ucsb.localization;

import java.util.ArrayList;

import android.util.Log;



public class StepDetector{
	private ArrayList<AccelData> Data; // Accelerometer data array 
	
	private double dataCurr;
	private long dataCurrTS;
	//private double dataPrev;
	//private long dataPrevTS;
	private double peakValue;
	private long peakTS;                // find a way to use this to improve accuracy (done?)
	private boolean peakVerified;
	private double troughValue;
	private long troughTS;				// find a way to use this to improve accuracy
	private boolean troughVerified;
	private double peakAvg;             // not final, has init value and constantly updated
	private double troughAvg;
	private double waveformAvg;         // find a way to use this to improve accuracy
	private final int stepAxis;
	private final double PEAKAVGTHRESH;   //should be determined from training phase (largest diff between peak and avg peak)
	private final double TROUGHAVGTHRESH; //should be determined from training phase (largest diff between trough and avg trough)
	private final double DIFFAVGTHRESH;   //should be determined from training phase (largest diff between peak and trough)
	private final int LOOKLENGTH = 20;
	private double TROUGHTIMEOUT = 0;
	private int peakLookCounter;
	private int troughLookCounter;
	
	public StepDetector(int AXIS, double initPeakAvg, double peakThresh, double inittroughAvg, double troughThresh, double diffThresh){
		dataCurr = 0;
		dataCurrTS = 0;
		peakValue = 0;
		peakTS = 0;
		troughValue= 0;
		troughTS = 0;
		troughAvg = 0;
		waveformAvg = 0;
		peakLookCounter = 0;
		troughLookCounter = 0;
		peakVerified = false;
		troughVerified = false;
		this.peakAvg = initPeakAvg;
		this.troughAvg = inittroughAvg;
		this.PEAKAVGTHRESH = peakThresh;
		this.TROUGHAVGTHRESH = troughThresh;
		this.DIFFAVGTHRESH = diffThresh;
		this.stepAxis = AXIS;  //cannot be changed (final)
		
		
	}
	
	public void updateArray(ArrayList<AccelData> Data, double[] currFreq){
		this.Data = Data;
		this.TROUGHTIMEOUT = 1000/currFreq[this.stepAxis];  //timeout in ms
		return;
	}
	
	public boolean FindStep(){
		boolean stepVerified = false;
		
		dataCurr = Data.get(Data.size()-1).getValue(this.stepAxis);
		dataCurrTS = Data.get(Data.size()-1).getTimestamp();
		
		findPeak();
		peakVerified = verifyPeak();
		
		if (peakVerified){
			findTrough();
			troughTimeout();
			troughVerified = verifyTrough();
			if (troughVerified){
				stepVerified = verifyStep();
				resetDetect();
				return stepVerified;
			}
		}
		
		return stepVerified;
	}
		
	public void findPeak(){
		double Prev = 0;
		if (peakValue == 0){
			int j = 1;
			while (j < LOOKLENGTH){
				Prev = Data.get(Data.size()-1-j).getValue(this.stepAxis);
				if (Prev > dataCurr)
					break; //not a true peak
				j++;
			}
			if (j == LOOKLENGTH && Math.abs(dataCurr - peakAvg) < PEAKAVGTHRESH){
				// found a peak, need to verify
				peakValue = dataCurr; // store the supposed peak
				peakTS = dataCurrTS; // get peak time stamp
				Log.d("MyApp", "found a peak");
			}
		}
		return;
	}
	
	public boolean verifyPeak(){
		// if you have a peak, and its not been verified (yet - counter determines yet)
		if (peakValue != 0 && peakVerified == false && peakLookCounter < LOOKLENGTH){
			//still need to verify the current "supposed" peak
			if (peakValue > dataCurr){
				peakLookCounter++;
			}
			else {  //not a true peak resume find peak with current value
				peakValue = 0;
				peakTS = 0;
				peakLookCounter = 0;
				findPeak();
			}
			return false;
		}
		else{
			Log.d("MyApp", "peak Verified");
			peakLookCounter = 0;
		}
		return true;
	}
	
	public void findTrough(){
		if (troughValue == 0){
			// we have a verified peak, lets look for a trough here
			double Prev = Data.get(Data.size()-2).getValue(this.stepAxis);
			long PrevTS = Data.get(Data.size()-2).getTimestamp();
			if(dataCurr > Prev){ //started going back up = possible trough
				if (Math.abs(Prev - troughAvg) < TROUGHAVGTHRESH){
					Log.d("MyApp","found a trough");
					troughValue = Prev;
					troughTS = PrevTS;
				}
			}
		}
		return;
	}
	
	public boolean verifyTrough(){
		// if you have a trough, and its not been verified (yet - counter determines yet)
		if (troughValue != 0 && troughVerified == false && troughLookCounter < LOOKLENGTH){
			//still need to verify the current "supposed" trough
			if (troughValue < dataCurr){
				troughLookCounter++;
			}
			else {  //not a true trough resume find trough with current value
				troughValue = 0;
				troughTS = 0;
				troughLookCounter = 0;
				findTrough();
			}
			return false;
		}
		else{
			Log.d("MyApp","trough Verified");
			troughLookCounter = 0;
		}
		return true;
	}
	
	public boolean verifyStep(){
		if ((peakValue - troughValue) > DIFFAVGTHRESH){
			Log.d("MyApp","Step Verified!");
			return true;
		}
		return false;
	}
	
	public void troughTimeout(){
		
		if (peakTS - dataCurrTS > TROUGHTIMEOUT){
			resetDetect();
		}
		
		return;
	}
	
	public void resetDetect(){
		peakValue = 0;
		peakTS = 0;
		troughValue= 0;
		troughTS = 0;
		peakVerified = false;
		troughVerified = false;
	}
	
}

