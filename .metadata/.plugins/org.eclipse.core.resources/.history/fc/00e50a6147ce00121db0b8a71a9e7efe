package ece596.ucsb.localizedwifi;

import android.graphics.Bitmap;
import android.support.v4.app.FragmentActivity;
import android.support.v4.app.FragmentManager;

import com.google.android.gms.maps.CameraUpdateFactory;
import com.google.android.gms.maps.GoogleMap;
import com.google.android.gms.maps.MapFragment;
import com.google.android.gms.maps.SupportMapFragment;
import com.google.android.gms.maps.model.BitmapDescriptorFactory;
import com.google.android.gms.maps.model.GroundOverlayOptions;
import com.google.android.gms.maps.model.LatLng;
import com.google.android.gms.maps.model.LatLngBounds;

public class MapUI extends FragmentActivity{
	
	//Map Variables
	private GoogleMap mMap;	
	private Bitmap HFHFloorPlan;
	private Bitmap arrow;
	
	//consts
	private static final LatLng HFH_COORDS = new LatLng(34.413812, -119.84137);
	private static final double RADIUSEARTH = 6367000;
	private double mapScale = 11.4;

	
	public static FragmentManager fm;
	
	public MapUI(){
	
		mMap = ((SupportMapFragment) getSupportFragmentManager().findFragmentById(R.id.map)).getMap();
		fm = getSupportFragmentManager();
	
	}
	private void setUpMapIfNeeded() {
	    // Do a null check to confirm that we have not already instantiated the map.
	    if (mMap == null) {
	        mMap = ((MapFragment) getFragmentManager().findFragmentById(R.id.map))
	                            .getMap();
	        // Check if we were successful in obtaining the map.
	        if (mMap != null) {
	        	mMap.moveCamera(CameraUpdateFactory.newLatLngZoom(HFH_COORDS, 16));
	        	/*
	        	mMap.
	    		  		  map:uiCompass="false"
	    		  		  map:uiRotateGestures="true"
	    		  		  map:uiScrollGestures="true"
	    		  		  map:uiTiltGestures="false"
	    		  		  map:uiZoomControls="false"
	    		  		  map:uiZoomGestures="true"
	    		 */

	        }
	    }
	}
	
	public void updateDisplay(){
		//step_length_view.setText("Step Length is: " + Double.toString(step_length));
		//angleWRTN_view.setText("Angle WRTN is: " + Double.toString(theta) + " degrees");
		//distance_view.setText(Integer.toString(step_num) + " Steps and " + Double.toString(total_distance) + " Meters");
		
		return;
	}
	
	
	/// <summary>
	/// Calculates the end-point from a given source at a given range (meters) and bearing (degrees).
	/// This methods uses simple geometry equations to calculate the end-point.
	/// </summary>
	/// <param name="source">Point of origin</param>
	/// <param name="range">Range in meters</param>
	/// <param name="bearing">Bearing in degrees</param>
	/// <returns>End-point from the source given the desired range and bearing.</returns>
	public LatLng CalculateDerivedPosition(LatLng source, double range, double angleWRTN)
	{
	    double latA = Math.toRadians(source.latitude);
	    double lonA = Math.toRadians(source.longitude);
	    double angularDistance = range * mapScale / RADIUSEARTH;
	    double trueCourse = Math.toRadians(angleWRTN);

	    double lat = Math.asin(
	        Math.sin(latA) * Math.cos(angularDistance) + 
	        Math.cos(latA) * Math.sin(angularDistance) * Math.cos(trueCourse));

	    double dlon = Math.atan2(
	        Math.sin(trueCourse) * Math.sin(angularDistance) * Math.cos(latA), 
	        Math.cos(angularDistance) - Math.sin(latA) * Math.sin(lat));

	    double lon = ((lonA + dlon + Math.PI) % (Math.PI*2)) - Math.PI;

	    return new LatLng(Math.toDegrees(lat), Math.toDegrees(lon));
	}
	
	
	public double LatLontoMeter(double startLat, double startLon, double endLat, double endLon){
		double dlon = (endLon - startLon);
		double dlat = (endLat - startLat);
		dlon = (dlon * Math.PI/180);
		dlat = (dlat * Math.PI/180);
		double a = Math.pow(Math.sin(dlat/2),2) + Math.cos(startLat*Math.PI/180)*Math.cos(endLat*Math.PI/180)*Math.pow(Math.sin(dlon/2),2);
		double c = 2 * Math.atan2(Math.sqrt(a),  Math.sqrt(1-a));
		double d = RADIUSEARTH * c;
		
		return d;
	}
	
	public void updateCursor(double distance, double angleWRTN){
		arrowOverlay.remove();
		
		arrow_sw = CalculateDerivedPosition(arrow_sw, distance, angleWRTN);
		arrow_ne = CalculateDerivedPosition(arrow_ne, distance, angleWRTN);
		LatLngBounds arrow_bounds = new LatLngBounds(arrow_sw, arrow_ne);    // get a bounds
		
		arrowOverlay = mMap.addGroundOverlay(new GroundOverlayOptions()   // overlay the arrow
	     .image(BitmapDescriptorFactory.fromBitmap(arrow))
	     .positionFromBounds(arrow_bounds)
	     .transparency(0.7f));
		
		return;
	}

}
